(69, {$R-,Q-,S-})
(4, Const)
(66, InFile)
(43, =)
(69, 'cashier.in')
(51, ;)
(66, Limit)
(43, =)
(67, 110000)
(51, ;)
(66, H)
(43, =)
(67, 0x1f2f3f)
(51, ;)
(66, oc)
(43, =)
(67, 01234)
(51, ;)
(66, h_e)
(43, =)
(67, 0x1)
(66, m)
(51, ;)
(66, o_e)
(43, =)
(67, 02)
(66, m)
(51, ;)
(66, long_str)
(43, =)
(66, jjjjjjjjjjjjjk)
(66, long_str_2)
(43, =)
(66, erjkjakersdfklkl)
(30, Type)
(66, Tnode)
(43, =)
(25, record)
(66, key)
(49, ,)
(66, sum)
(49, ,)
(66, lc)
(49, ,)
(66, rc)
(49, ,)
(66, father)
(50, :)
(66, longint)
(51, ;)
(9, end)
(51, ;)
(66, Ttree)
(43, =)
(66, object)
(66, rootT)
(49, ,)
(66, tot)
(50, :)
(66, longint)
(51, ;)
(66, data)
(50, :)
(1, array)
(60, [)
(67, 0)
(65, ..)
(66, Limit)
(61, ])
(20, of)
(66, Tnode)
(51, ;)
(9, end)
(51, ;)
(32, Var)
(66, tree)
(50, :)
(66, Ttree)
(51, ;)
(66, totLeft)
(49, ,)
(66, init_Bound)
(49, ,)
(66, N)
(49, ,)
(66, Bound)
(50, :)
(66, longint)
(51, ;)
(66, procedure)
(66, Ttree)
(56, .)
(66, init)
(51, ;)
(2, begin)
(66, rootT)
(64, :=)
(66, nilT)
(51, ;)
(66, tot)
(64, :=)
(67, 0;)
(66, data)
(60, [)
(66, nilT)
(61, ])
(56, .)
(66, lc)
(64, :=)
(67, 0;)
(66, data)
(60, [)
(66, nilT)
(61, ])
(56, .)
(66, rc)
(64, :=)
(67, 0;)
(66, data)
(60, [)
(66, nilT)
(61, ])
(56, .)
(66, father)
(64, :=)
(67, 0;)
(66, data)
(60, [)
(66, nilT)
(61, ])
(56, .)
(66, sum)
(64, :=)
(67, 0;)
(66, data)
(60, [)
(66, nilT)
(61, ])
(56, .)
(66, key)
(64, :=)
(67, 0;)
(9, end)
(51, ;)
(66, procedure)
(66, Ttree)
(56, .)
(66, maintain)
(58, ()
(66, p)
(50, :)
(66, longint)
(59, ))
(51, ;)
(2, begin)
(66, data)
(60, [)
(66, nilT)
(61, ])
(56, .)
(66, sum)
(64, :=)
(67, 0;)
(66, data)
(60, [)
(66, p)
(61, ])
(56, .)
(66, sum)
(64, :=)
(66, data)
(60, [)
(66, data)
(60, [)
(66, p)
(61, ])
(56, .)
(66, lc)
(61, ])
(56, .)
(66, sum)
(35, +)
(66, data)
(60, [)
(66, data)
(60, [)
(66, p)
(61, ])
(56, .)
(66, rc)
(61, ])
(56, .)
(66, sum)
(35, +)
(67, 1)
(51, ;)
(9, end)
(51, ;)
(66, procedure)
(66, Ttree)
(56, .)
(66, Left_Rotate)
(58, ()
(66, p)
(50, :)
(66, longint)
(59, ))
(51, ;)
(32, var)
(66, x)
(49, ,)
(66, y)
(50, :)
(66, longint)
(51, ;)
(2, begin)
(66, x)
(64, :=)
(66, data)
(60, [)
(66, p)
(61, ])
(56, .)
(66, father)
(51, ;)
(66, y)
(64, :=)
(66, data)
(60, [)
(66, p)
(61, ])
(56, .)
(66, lc)
(51, ;)
(66, data)
(60, [)
(66, p)
(61, ])
(56, .)
(66, lc)
(64, :=)
(66, x)
(51, ;)
(66, data)
(60, [)
(66, x)
(61, ])
(56, .)
(66, rc)
(64, :=)
(66, y)
(51, ;)
(14, if)
(66, data)
(60, [)
(66, x)
(61, ])
(56, .)
(66, father)
(43, =)
(66, nilT)
(28, then)
(66, rootT)
(64, :=)
(66, p)
(8, else)
(14, if)
(66, data)
(60, [)
(66, data)
(60, [)
(66, x)
(61, ])
(56, .)
(66, father)
(61, ])
(56, .)
(66, lc)
(43, =)
(66, x)
(28, then)
(66, data)
(60, [)
(66, data)
(60, [)
(66, x)
(61, ])
(56, .)
(66, father)
(61, ])
(56, .)
(66, lc)
(64, :=)
(66, p)
(8, else)
(66, data)
(60, [)
(66, data)
(60, [)
(66, x)
(61, ])
(56, .)
(66, father)
(61, ])
(56, .)
(66, rc)
(64, :=)
(66, p)
(51, ;)
(66, data)
(60, [)
(66, p)
(61, ])
(56, .)
(66, father)
(64, :=)
(66, data)
(60, [)
(66, x)
(61, ])
(56, .)
(66, father)
(51, ;)
(66, data)
(60, [)
(66, x)
(61, ])
(56, .)
(66, father)
(64, :=)
(66, p)
(51, ;)
(66, data)
(60, [)
(66, y)
(61, ])
(56, .)
(66, father)
(64, :=)
(66, x)
(51, ;)
(66, maintain)
(58, ()
(66, x)
(59, ))
(51, ;)
(66, maintain)
(58, ()
(66, p)
(59, ))
(51, ;)
(9, end)
(51, ;)
(66, procedure)
(66, Ttree)
(56, .)
(66, Right_Rotate)
(58, ()
(66, p)
(50, :)
(66, longint)
(59, ))
(51, ;)
(32, var)
(66, x)
(49, ,)
(66, y)
(50, :)
(66, longint)
(51, ;)
(2, begin)
(66, x)
(64, :=)
(66, data)
(60, [)
(66, p)
(61, ])
(56, .)
(66, father)
(51, ;)
(66, y)
(64, :=)
(66, data)
(60, [)
(66, p)
(61, ])
(56, .)
(66, rc)
(51, ;)
(66, data)
(60, [)
(66, p)
(61, ])
(56, .)
(66, rc)
(64, :=)
(66, x)
(51, ;)
(66, data)
(60, [)
(66, x)
(61, ])
(56, .)
(66, lc)
(64, :=)
(66, y)
(51, ;)
(14, if)
(66, data)
(60, [)
(66, x)
(61, ])
(56, .)
(66, father)
(43, =)
(66, nilT)
(28, then)
(66, rootT)
(64, :=)
(66, p)
(8, else)
(14, if)
(66, data)
(60, [)
(66, data)
(60, [)
(66, x)
(61, ])
(56, .)
(66, father)
(61, ])
(56, .)
(66, lc)
(43, =)
(66, x)
(28, then)
(66, data)
(60, [)
(66, data)
(60, [)
(66, x)
(61, ])
(56, .)
(66, father)
(61, ])
(56, .)
(66, lc)
(64, :=)
(66, p)
(8, else)
(66, data)
(60, [)
(66, data)
(60, [)
(66, x)
(61, ])
(56, .)
(66, father)
(61, ])
(56, .)
(66, rc)
(64, :=)
(66, p)
(51, ;)
(66, data)
(60, [)
(66, p)
(61, ])
(56, .)
(66, father)
(64, :=)
(66, data)
(60, [)
(66, x)
(61, ])
(56, .)
(66, father)
(51, ;)
(66, data)
(60, [)
(66, x)
(61, ])
(56, .)
(66, father)
(64, :=)
(66, p)
(51, ;)
(66, data)
(60, [)
(66, y)
(61, ])
(56, .)
(66, father)
(64, :=)
(66, x)
(51, ;)
(66, maintain)
(58, ()
(66, x)
(59, ))
(51, ;)
(66, maintain)
(58, ()
(66, p)
(59, ))
(51, ;)
(9, end)
(51, ;)
(66, procedure)
(66, Ttree)
(56, .)
(66, Rotate)
(58, ()
(66, p)
(50, :)
(66, longint)
(59, ))
(51, ;)
(2, begin)
(14, if)
(66, data)
(60, [)
(66, data)
(60, [)
(66, p)
(61, ])
(56, .)
(66, father)
(61, ])
(56, .)
(66, lc)
(43, =)
(66, p)
(28, then)
(66, Right_Rotate)
(58, ()
(66, p)
(59, ))
(8, else)
(66, Left_Rotate)
(58, ()
(66, p)
(59, ))
(51, ;)
(9, end)
(51, ;)
(66, procedure)
(66, Ttree)
(56, .)
(66, Splay)
(58, ()
(66, p)
(50, :)
(66, longint)
(59, ))
(51, ;)
(32, var)
(66, x)
(50, :)
(66, longint)
(51, ;)
(2, begin)
(33, while)
(66, p)
(44, <>)
(66, rootT)
(6, do)
(14, if)
(66, data)
(60, [)
(66, p)
(61, ])
(56, .)
(66, father)
(43, =)
(66, rootT)
(28, then)
(66, Rotate)
(58, ()
(66, p)
(59, ))
(8, else)
(2, begin)
(66, x)
(64, :=)
(66, data)
(60, [)
(66, p)
(61, ])
(56, .)
(66, father)
(51, ;)
(14, if)
(58, ()
(66, data)
(60, [)
(66, data)
(60, [)
(66, x)
(61, ])
(56, .)
(66, father)
(61, ])
(56, .)
(66, lc)
(43, =)
(66, x)
(59, ))
(43, =)
(58, ()
(66, data)
(60, [)
(66, x)
(61, ])
(56, .)
(66, lc)
(43, =)
(66, p)
(59, ))
(28, then)
(2, begin)
(66, Rotate)
(58, ()
(66, x)
(59, ))
(51, ;)
(66, Rotate)
(58, ()
(66, p)
(59, ))
(51, ;)
(9, end)
(8, else)
(2, begin)
(66, Rotate)
(58, ()
(66, p)
(59, ))
(51, ;)
(66, Rotate)
(58, ()
(66, p)
(59, ))
(51, ;)
(9, end)
(51, ;)
(9, end)
(51, ;)
(9, end)
(51, ;)
(66, procedure)
(66, Ttree)
(56, .)
(66, Insert)
(58, ()
(66, key)
(50, :)
(66, longint)
(59, ))
(51, ;)
(32, var)
(66, p)
(49, ,)
(66, fp)
(50, :)
(66, longint)
(51, ;)
(2, begin)
(66, inc)
(58, ()
(66, tot)
(59, ))
(51, ;)
(66, data)
(60, [)
(66, tot)
(61, ])
(56, .)
(66, key)
(64, :=)
(66, key)
(51, ;)
(66, data)
(60, [)
(66, tot)
(61, ])
(56, .)
(66, lc)
(64, :=)
(67, 0;)
(66, data)
(60, [)
(66, tot)
(61, ])
(56, .)
(66, rc)
(64, :=)
(67, 0;)
(66, data)
(60, [)
(66, tot)
(61, ])
(56, .)
(66, father)
(64, :=)
(67, 0;)
(66, data)
(60, [)
(66, tot)
(61, ])
(56, .)
(66, sum)
(64, :=)
(67, 1)
(51, ;)
(14, if)
(66, rootT)
(43, =)
(66, nilT)
(28, then)
(66, rootT)
(64, :=)
(66, tot)
(8, else)
(2, begin)
(66, p)
(64, :=)
(66, rootT)
(51, ;)
(66, fp)
(64, :=)
(67, 0;)
(33, while)
(66, p)
(44, <>)
(66, nilT)
(6, do)
(2, begin)
(66, inc)
(58, ()
(66, data)
(60, [)
(66, p)
(61, ])
(56, .)
(66, sum)
(59, ))
(51, ;)
(66, fp)
(64, :=)
(66, p)
(51, ;)
(14, if)
(66, data)
(60, [)
(66, p)
(61, ])
(56, .)
(66, key)
(47, <)
(66, key)
(28, then)
(66, p)
(64, :=)
(66, data)
(60, [)
(66, p)
(61, ])
(56, .)
(66, rc)
(8, else)
(66, p)
(64, :=)
(66, data)
(60, [)
(66, p)
(61, ])
(56, .)
(66, lc)
(51, ;)
(9, end)
(51, ;)
(14, if)
(66, data)
(60, [)
(66, fp)
(61, ])
(56, .)
(66, key)
(47, <)
(66, key)
(28, then)
(66, data)
(60, [)
(66, fp)
(61, ])
(56, .)
(66, rc)
(64, :=)
(66, tot)
(8, else)
(66, data)
(60, [)
(66, fp)
(61, ])
(56, .)
(66, lc)
(64, :=)
(66, tot)
(51, ;)
(66, data)
(60, [)
(66, tot)
(61, ])
(56, .)
(66, father)
(64, :=)
(66, fp)
(51, ;)
(66, Splay)
(58, ()
(66, tot)
(59, ))
(51, ;)
(9, end)
(51, ;)
(9, end)
(51, ;)
(12, function)
(66, Ttree)
(56, .)
(66, Find)
(58, ()
(66, key)
(50, :)
(66, longint)
(59, ))
(50, :)
(66, longint)
(51, ;)
(32, var)
(66, p)
(49, ,)
(66, fp)
(50, :)
(66, longint)
(51, ;)
(2, begin)
(66, Find)
(64, :=)
(36, -)
(67, 1)
(51, ;)
(14, if)
(66, rootT)
(43, =)
(66, nilT)
(28, then)
(66, exit)
(51, ;)
(66, p)
(64, :=)
(66, rootT)
(51, ;)
(66, fp)
(64, :=)
(67, 0;)
(33, while)
(66, p)
(44, <>)
(66, nilT)
(6, do)
(2, begin)
(66, fp)
(64, :=)
(66, p)
(51, ;)
(14, if)
(66, data)
(60, [)
(66, p)
(61, ])
(56, .)
(66, key)
(47, <)
(66, key)
(28, then)
(2, begin)
(66, Find)
(64, :=)
(66, p)
(51, ;)
(66, p)
(64, :=)
(66, data)
(60, [)
(66, p)
(61, ])
(56, .)
(66, rc)
(51, ;)
(9, end)
(8, else)
(66, p)
(64, :=)
(66, data)
(60, [)
(66, p)
(61, ])
(56, .)
(66, lc)
(51, ;)
(9, end)
(51, ;)
(66, Splay)
(58, ()
(66, fp)
(59, ))
(51, ;)
(9, end)
(51, ;)
(12, function)
(66, Ttree)
(56, .)
(66, Find_Index)
(58, ()
(66, sum)
(50, :)
(66, longint)
(59, ))
(50, :)
(66, longint)
(51, ;)
(32, var)
(66, p)
(50, :)
(66, longint)
(51, ;)
(2, begin)
(66, Find_Index)
(64, :=)
(36, -)
(67, 1)
(51, ;)
(14, if)
(66, sum)
(45, >)
(66, data)
(60, [)
(66, rootT)
(61, ])
(56, .)
(66, sum)
(28, then)
(66, exit)
(51, ;)
(66, sum)
(64, :=)
(66, data)
(60, [)
(66, rootT)
(61, ])
(56, .)
(66, sum)
(36, -)
(66, sum)
(35, +)
(67, 1)
(51, ;)
(66, p)
(64, :=)
(66, rootT)
(51, ;)
(33, while)
(66, true)
(6, do)
(14, if)
(66, sum)
(48, <=)
(66, data)
(60, [)
(66, data)
(60, [)
(66, p)
(61, ])
(56, .)
(66, lc)
(61, ])
(56, .)
(66, sum)
(28, then)
(66, p)
(64, :=)
(66, data)
(60, [)
(66, p)
(61, ])
(56, .)
(66, lc)
(8, else)
(14, if)
(66, sum)
(43, =)
(66, data)
(60, [)
(66, data)
(60, [)
(66, p)
(61, ])
(56, .)
(66, lc)
(61, ])
(56, .)
(66, sum)
(35, +)
(67, 1)
(28, then)
(2, begin)
(66, Splay)
(58, ()
(66, p)
(59, ))
(51, ;)
(66, Find_Index)
(64, :=)
(66, p)
(51, ;)
(66, exit)
(51, ;)
(9, end)
(8, else)
(2, begin)
(66, dec)
(58, ()
(66, sum)
(49, ,)
(66, data)
(60, [)
(66, data)
(60, [)
(66, p)
(61, ])
(56, .)
(66, lc)
(61, ])
(56, .)
(66, sum)
(35, +)
(67, 1)
(59, ))
(51, ;)
(66, p)
(64, :=)
(66, data)
(60, [)
(66, p)
(61, ])
(56, .)
(66, rc)
(51, ;)
(9, end)
(51, ;)
(9, end)
(51, ;)
(66, procedure)
(66, Ttree)
(56, .)
(66, Delete_Root_Lc)
(51, ;)
(2, begin)
(14, if)
(66, rootT)
(43, =)
(66, nilT)
(28, then)
(66, exit)
(51, ;)
(14, if)
(66, data)
(60, [)
(66, rootT)
(61, ])
(56, .)
(66, Rc)
(43, =)
(66, nilT)
(28, then)
(2, begin)
(66, rootT)
(64, :=)
(66, nilT)
(51, ;)
(66, exit)
(51, ;)
(9, end)
(51, ;)
(66, rootT)
(64, :=)
(66, data)
(60, [)
(66, rootT)
(61, ])
(56, .)
(66, Rc)
(51, ;)
(66, data)
(60, [)
(66, rootT)
(61, ])
(56, .)
(66, father)
(64, :=)
(66, nilT)
(51, ;)
(9, end)
(51, ;)
(66, procedure)
(66, main)
(51, ;)
(32, var)
(66, i)
(49, ,)
(66, K)
(49, ,)
(66, p)
(50, :)
(66, longint)
(51, ;)
(66, ch)
(50, :)
(66, char)
(51, ;)
(2, begin)
(66, assign)
(58, ()
(66, INPUT)
(49, ,)
(66, InFile)
(59, ))
(51, ;)
(66, ReSet)
(58, ()
(66, INPUT)
(59, ))
(51, ;)
(66, assign)
(58, ()
(66, OUTPUT)
(49, ,)
(66, OutFile)
(59, ))
(51, ;)
(66, ReWrite)
(58, ()
(66, OUTPUT)
(59, ))
(51, ;)
(66, readln)
(58, ()
(66, N)
(49, ,)
(66, Bound)
(59, ))
(51, ;)
(66, init_Bound)
(64, :=)
(66, Bound)
(51, ;)
(66, tree)
(56, .)
(66, init)
(51, ;)
(66, totLeft)
(64, :=)
(67, 0;)
(11, for)
(66, i)
(64, :=)
(67, 1)
(29, to)
(66, N)
(6, do)
(2, begin)
(66, readln)
(58, ()
(66, ch)
(49, ,)
(66, K)
(59, ))
(51, ;)
(3, case)
(66, ch)
(20, of)
(69, 'I')
(50, :)
(2, begin)
(14, if)
(66, K)
(47, <)
(66, init_Bound)
(28, then)
(66, inc)
(58, ()
(66, totLeft)
(59, ))
(8, else)
(66, tree)
(56, .)
(66, Insert)
(58, ()
(66, K)
(36, -)
(66, init_Bound)
(35, +)
(66, Bound)
(59, ))
(51, ;)
(9, end)
(51, ;)
(69, 'A')
(50, :)
(66, dec)
(58, ()
(66, Bound)
(49, ,)
(66, K)
(59, ))
(51, ;)
(69, 'S')
(50, :)
(2, begin)
(66, inc)
(58, ()
(66, Bound)
(49, ,)
(66, K)
(59, ))
(51, ;)
(66, p)
(64, :=)
(66, tree)
(56, .)
(66, Find)
(58, ()
(66, Bound)
(59, ))
(51, ;)
(14, if)
(66, p)
(44, <>)
(36, -)
(67, 1)
(28, then)
(2, begin)
(66, tree)
(56, .)
(66, Splay)
(58, ()
(66, p)
(59, ))
(51, ;)
(66, inc)
(58, ()
(66, totLeft)
(49, ,)
(66, tree)
(56, .)
(66, data)
(60, [)
(66, tree)
(56, .)
(66, data)
(60, [)
(66, p)
(61, ])
(56, .)
(66, lc)
(61, ])
(56, .)
(66, sum)
(35, +)
(67, 1)
(59, ))
(51, ;)
(66, tree)
(56, .)
(66, Delete_Root_Lc)
(51, ;)
(9, end)
(51, ;)
(9, end)
(51, ;)
(69, 'F')
(50, :)
(2, begin)
(66, p)
(64, :=)
(66, tree)
(56, .)
(66, Find_Index)
(58, ()
(66, K)
(59, ))
(51, ;)
(14, if)
(66, p)
(43, =)
(36, -)
(67, 1)
(28, then)
(66, 