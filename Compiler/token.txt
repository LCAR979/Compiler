(4, Const)
(64, InFile)
(43, =)
(67, 'cashier.in')
(51, ;)
(64, Limit)
(43, =)
(65, 110000)
(51, ;)
(64, H)
(43, =)
(65, 0x1f2f3f)
(51, ;)
(64, oc)
(43, =)
(65, 01234)
(51, ;)
(64, h_e)
(43, =)
(65, 0x1)
(64, m)
(51, ;)
(64, o_e)
(43, =)
(65, 02)
(64, m)
(51, ;)
(64, long_str)
(43, =)
(64, jjjjjjjjjjjjjk)
(64, long_str_2)
(43, =)
(64, erjkjakersdfklkl)
(30, Type)
(64, Tnode)
(43, =)
(25, record)
(64, key)
(49, ,)
(64, sum)
(49, ,)
(64, lc)
(49, ,)
(64, rc)
(49, ,)
(64, father)
(50, :)
(64, longint)
(51, ;)
(9, end)
(51, ;)
(64, Ttree)
(43, =)
(64, object)
(64, rootT)
(49, ,)
(64, tot)
(50, :)
(64, longint)
(51, ;)
(64, data)
(50, :)
(1, array)
(60, [)
(65, 0)
(63, ..)
(64, Limit)
(61, ])
(20, of)
(64, Tnode)
(51, ;)
(9, end)
(51, ;)
(32, Var)
(64, tree)
(50, :)
(64, Ttree)
(51, ;)
(64, totLeft)
(49, ,)
(24, init_Bound)
(49, ,)
(64, N)
(49, ,)
(64, Bound)
(50, :)
(64, longint)
(51, ;)
(64, procedure)
(64, Ttree)
(56, .)
(15, init)
(51, ;)
(2, begin)
(64, rootT)
(62, :=)
(28, nilT)
(51, ;)
(64, tot)
(62, :=)
(65, 0;)
(64, data)
(60, [)
(28, nilT)
(61, ])
(56, .)
(64, lc)
(62, :=)
(65, 0;)
(64, data)
(60, [)
(28, nilT)
(61, ])
(56, .)
(64, rc)
(62, :=)
(65, 0;)
(64, data)
(60, [)
(28, nilT)
(61, ])
(56, .)
(64, father)
(62, :=)
(65, 0;)
(64, data)
(60, [)
(28, nilT)
(61, ])
(56, .)
(64, sum)
(62, :=)
(65, 0;)
(64, data)
(60, [)
(28, nilT)
(61, ])
(56, .)
(64, key)
(62, :=)
(65, 0;)
(9, end)
(51, ;)
(64, procedure)
(64, Ttree)
(56, .)
(64, maintain)
(58, ()
(64, p)
(50, :)
(64, longint)
(59, ))
(51, ;)
(2, begin)
(64, data)
(60, [)
(28, nilT)
(61, ])
(56, .)
(64, sum)
(62, :=)
(65, 0;)
(64, data)
(60, [)
(64, p)
(61, ])
(56, .)
(64, sum)
(62, :=)
(64, data)
(60, [)
(64, data)
(60, [)
(64, p)
(61, ])
(56, .)
(64, lc)
(61, ])
(56, .)
(64, sum)
(35, +)
(64, data)
(60, [)
(64, data)
(60, [)
(64, p)
(61, ])
(56, .)
(64, rc)
(61, ])
(56, .)
(64, sum)
(35, +)
(65, 1)
(51, ;)
(9, end)
(51, ;)
(64, procedure)
(64, Ttree)
(56, .)
(64, Left_Rotate)
(58, ()
(64, p)
(50, :)
(64, longint)
(59, ))
(51, ;)
(32, var)
(64, x)
(49, ,)
(64, y)
(50, :)
(64, longint)
(51, ;)
(2, begin)
(64, x)
(62, :=)
(64, data)
(60, [)
(64, p)
(61, ])
(56, .)
(64, father)
(51, ;)
(64, y)
(62, :=)
(64, data)
(60, [)
(64, p)
(61, ])
(56, .)
(64, lc)
(51, ;)
(64, data)
(60, [)
(64, p)
(61, ])
(56, .)
(64, lc)
(62, :=)
(64, x)
(51, ;)
(64, data)
(60, [)
(64, x)
(61, ])
(56, .)
(64, rc)
(62, :=)
(64, y)
(51, ;)
(14, if)
(64, data)
(60, [)
(64, x)
(61, ])
(56, .)
(64, father)
(43, =)
(28, nilT)
(28, then)
(64, rootT)
(62, :=)
(64, p)
(8, else)
(14, if)
(64, data)
(60, [)
(64, data)
(60, [)
(64, x)
(61, ])
(56, .)
(64, father)
(61, ])
(56, .)
(64, lc)
(43, =)
(64, x)
(28, then)
(64, data)
(60, [)
(64, data)
(60, [)
(64, x)
(61, ])
(56, .)
(64, father)
(61, ])
(56, .)
(64, lc)
(62, :=)
(64, p)
(8, else)
(64, data)
(60, [)
(64, data)
(60, [)
(64, x)
(61, ])
(56, .)
(64, father)
(61, ])
(56, .)
(64, rc)
(62, :=)
(64, p)
(51, ;)
(64, data)
(60, [)
(64, p)
(61, ])
(56, .)
(64, father)
(62, :=)
(64, data)
(60, [)
(64, x)
(61, ])
(56, .)
(64, father)
(51, ;)
(64, data)
(60, [)
(64, x)
(61, ])
(56, .)
(64, father)
(62, :=)
(64, p)
(51, ;)
(64, data)
(60, [)
(64, y)
(61, ])
(56, .)
(64, father)
(62, :=)
(64, x)
(51, ;)
(64, maintain)
(58, ()
(64, x)
(59, ))
(51, ;)
(64, maintain)
(58, ()
(64, p)
(59, ))
(51, ;)
(9, end)
(51, ;)
(64, procedure)
(64, Ttree)
(56, .)
(64, Right_Rotate)
(58, ()
(64, p)
(50, :)
(64, longint)
(59, ))
(51, ;)
(32, var)
(64, x)
(49, ,)
(64, y)
(50, :)
(64, longint)
(51, ;)
(2, begin)
(64, x)
(62, :=)
(64, data)
(60, [)
(64, p)
(61, ])
(56, .)
(64, father)
(51, ;)
(64, y)
(62, :=)
(64, data)
(60, [)
(64, p)
(61, ])
(56, .)
(64, rc)
(51, ;)
(64, data)
(60, [)
(64, p)
(61, ])
(56, .)
(64, rc)
(62, :=)
(64, x)
(51, ;)
(64, data)
(60, [)
(64, x)
(61, ])
(56, .)
(64, lc)
(62, :=)
(64, y)
(51, ;)
(14, if)
(64, data)
(60, [)
(64, x)
(61, ])
(56, .)
(64, father)
(43, =)
(28, nilT)
(28, then)
(64, rootT)
(62, :=)
(64, p)
(8, else)
(14, if)
(64, data)
(60, [)
(64, data)
(60, [)
(64, x)
(61, ])
(56, .)
(64, father)
(61, ])
(56, .)
(64, lc)
(43, =)
(64, x)
(28, then)
(64, data)
(60, [)
(64, data)
(60, [)
(64, x)
(61, ])
(56, .)
(64, father)
(61, ])
(56, .)
(64, lc)
(62, :=)
(64, p)
(8, else)
(64, data)
(60, [)
(64, data)
(60, [)
(64, x)
(61, ])
(56, .)
(64, father)
(61, ])
(56, .)
(64, rc)
(62, :=)
(64, p)
(51, ;)
(64, data)
(60, [)
(64, p)
(61, ])
(56, .)
(64, father)
(62, :=)
(64, data)
(60, [)
(64, x)
(61, ])
(56, .)
(64, father)
(51, ;)
(64, data)
(60, [)
(64, x)
(61, ])
(56, .)
(64, father)
(62, :=)
(64, p)
(51, ;)
(64, data)
(60, [)
(64, y)
(61, ])
(56, .)
(64, father)
(62, :=)
(64, x)
(51, ;)
(64, maintain)
(58, ()
(64, x)
(59, ))
(51, ;)
(64, maintain)
(58, ()
(64, p)
(59, ))
(51, ;)
(9, end)
(51, ;)
(64, procedure)
(64, Ttree)
(56, .)
(64, Rotate)
(58, ()
(64, p)
(50, :)
(64, longint)
(59, ))
(51, ;)
(2, begin)
(14, if)
(64, data)
(60, [)
(64, data)
(60, [)
(64, p)
(61, ])
(56, .)
(64, father)
(61, ])
(56, .)
(64, lc)
(43, =)
(64, p)
(28, then)
(64, Right_Rotate)
(58, ()
(64, p)
(59, ))
(8, else)
(64, Left_Rotate)
(58, ()
(64, p)
(59, ))
(51, ;)
(9, end)
(51, ;)
(64, procedure)
(64, Ttree)
(56, .)
(64, Splay)
(58, ()
(64, p)
(50, :)
(64, longint)
(59, ))
(51, ;)
(32, var)
(64, x)
(50, :)
(64, longint)
(51, ;)
(2, begin)
(33, while)
(64, p)
(44, <>)
(64, rootT)
(6, do)
(14, if)
(64, data)
(60, [)
(64, p)
(61, ])
(56, .)
(64, father)
(43, =)
(64, rootT)
(28, then)
(64, Rotate)
(58, ()
(64, p)
(59, ))
(8, else)
(2, begin)
(64, x)
(62, :=)
(64, data)
(60, [)
(64, p)
(61, ])
(56, .)
(64, father)
(51, ;)
(14, if)
(58, ()
(64, data)
(60, [)
(64, data)
(60, [)
(64, x)
(61, ])
(56, .)
(64, father)
(61, ])
(56, .)
(64, lc)
(43, =)
(64, x)
(59, ))
(43, =)
(58, ()
(64, data)
(60, [)
(64, x)
(61, ])
(56, .)
(64, lc)
(43, =)
(64, p)
(59, ))
(28, then)
(2, begin)
(64, Rotate)
(58, ()
(64, x)
(59, ))
(51, ;)
(64, Rotate)
(58, ()
(64, p)
(59, ))
(51, ;)
(9, end)
(8, else)
(2, begin)
(64, Rotate)
(58, ()
(64, p)
(59, ))
(51, ;)
(64, Rotate)
(58, ()
(64, p)
(59, ))
(51, ;)
(9, end)
(51, ;)
(9, end)
(51, ;)
(9, end)
(51, ;)
(64, procedure)
(64, Ttree)
(56, .)
(64, Insert)
(58, ()
(64, key)
(50, :)
(64, longint)
(59, ))
(51, ;)
(32, var)
(64, p)
(49, ,)
(64, fp)
(50, :)
(64, longint)
(51, ;)
(2, begin)
(64, inc)
(58, ()
(64, tot)
(59, ))
(51, ;)
(64, data)
(60, [)
(64, tot)
(61, ])
(56, .)
(64, key)
(62, :=)
(64, key)
(51, ;)
(64, data)
(60, [)
(64, tot)
(61, ])
(56, .)
(64, lc)
(62, :=)
(65, 0;)
(64, data)
(60, [)
(64, tot)
(61, ])
(56, .)
(64, rc)
(62, :=)
(65, 0;)
(64, data)
(60, [)
(64, tot)
(61, ])
(56, .)
(64, father)
(62, :=)
(65, 0;)
(64, data)
(60, [)
(64, tot)
(61, ])
(56, .)
(64, sum)
(62, :=)
(65, 1)
(51, ;)
(14, if)
(64, rootT)
(43, =)
(28, nilT)
(28, then)
(64, rootT)
(62, :=)
(64, tot)
(8, else)
(2, begin)
(64, p)
(62, :=)
(64, rootT)
(51, ;)
(64, fp)
(62, :=)
(65, 0;)
(33, while)
(64, p)
(44, <>)
(28, nilT)
(6, do)
(2, begin)
(64, inc)
(58, ()
(64, data)
(60, [)
(64, p)
(61, ])
(56, .)
(64, sum)
(59, ))
(51, ;)
(64, fp)
(62, :=)
(64, p)
(51, ;)
(14, if)
(64, data)
(60, [)
(64, p)
(61, ])
(56, .)
(64, key)
(47, <)
(64, key)
(28, then)
(64, p)
(62, :=)
(64, data)
(60, [)
(64, p)
(61, ])
(56, .)
(64, rc)
(8, else)
(64, p)
(62, :=)
(64, data)
(60, [)
(64, p)
(61, ])
(56, .)
(64, lc)
(51, ;)
(9, end)
(51, ;)
(14, if)
(64, data)
(60, [)
(64, fp)
(61, ])
(56, .)
(64, key)
(47, <)
(64, key)
(28, then)
(64, data)
(60, [)
(64, fp)
(61, ])
(56, .)
(64, rc)
(62, :=)
(64, tot)
(8, else)
(64, data)
(60, [)
(64, fp)
(61, ])
(56, .)
(64, lc)
(62, :=)
(64, tot)
(51, ;)
(64, data)
(60, [)
(64, tot)
(61, ])
(56, .)
(64, father)
(62, :=)
(64, fp)
(51, ;)
(64, Splay)
(58, ()
(64, tot)
(59, ))
(51, ;)
(9, end)
(51, ;)
(9, end)
(51, ;)
(12, function)
(64, Ttree)
(56, .)
(64, Find)
(58, ()
(64, key)
(50, :)
(64, longint)
(59, ))
(50, :)
(64, longint)
(51, ;)
(32, var)
(64, p)
(49, ,)
(64, fp)
(50, :)
(64, longint)
(51, ;)
(2, begin)
(64, Find)
(62, :=)
(36, -)
(65, 1)
(51, ;)
(14, if)
(64, rootT)
(43, =)
(28, nilT)
(28, then)
(64, exit)
(51, ;)
(64, p)
(62, :=)
(64, rootT)
(51, ;)
(64, fp)
(62, :=)
(65, 0;)
(33, while)
(64, p)
(44, <>)
(28, nilT)
(6, do)
(2, begin)
(64, fp)
(62, :=)
(64, p)
(51, ;)
(14, if)
(64, data)
(60, [)
(64, p)
(61, ])
(56, .)
(64, key)
(47, <)
(64, key)
(28, then)
(2, begin)
(64, Find)
(62, :=)
(64, p)
(51, ;)
(64, p)
(62, :=)
(64, data)
(60, [)
(64, p)
(61, ])
(56, .)
(64, rc)
(51, ;)
(9, end)
(8, else)
(64, p)
(62, :=)
(64, data)
(60, [)
(64, p)
(61, ])
(56, .)
(64, lc)
(51, ;)
(9, end)
(51, ;)
(64, Splay)
(58, ()
(64, fp)
(59, ))
(51, ;)
(9, end)
(51, ;)
(12, function)
(64, Ttree)
(56, .)
(64, Find_Index)
(58, ()
(64, sum)
(50, :)
(64, longint)
(59, ))
(50, :)
(64, longint)
(51, ;)
(32, var)
(64, p)
(50, :)
(64, longint)
(51, ;)
(2, begin)
(64, Find_Index)
(62, :=)
(36, -)
(65, 1)
(51, ;)
(14, if)
(64, sum)
(45, >)
(64, data)
(60, [)
(64, rootT)
(61, ])
(56, .)
(64, sum)
(28, then)
(64, exit)
(51, ;)
(64, sum)
(62, :=)
(64, data)
(60, [)
(64, rootT)
(61, ])
(56, .)
(64, sum)
(36, -)
(64, sum)
(35, +)
(65, 1)
(51, ;)
(64, p)
(62, :=)
(64, rootT)
(51, ;)
(33, while)
(64, true)
(6, do)
(14, if)
(64, sum)
(48, <=)
(64, data)
(60, [)
(64, data)
(60, [)
(64, p)
(61, ])
(56, .)
(64, lc)
(61, ])
(56, .)
(64, sum)
(28, then)
(64, p)
(62, :=)
(64, data)
(60, [)
(64, p)
(61, ])
(56, .)
(64, lc)
(8, else)
(14, if)
(64, sum)
(43, =)
(64, data)
(60, [)
(64, data)
(60, [)
(64, p)
(61, ])
(56, .)
(64, lc)
(61, ])
(56, .)
(64, sum)
(35, +)
(65, 1)
(28, then)
(2, begin)
(64, Splay)
(58, ()
(64, p)
(59, ))
(51, ;)
(64, Find_Index)
(62, :=)
(64, p)
(51, ;)
(64, exit)
(51, ;)
(9, end)
(8, else)
(2, begin)
(64, dec)
(58, ()
(64, sum)
(49, ,)
(64, data)
(60, [)
(64, data)
(60, [)
(64, p)
(61, ])
(56, .)
(64, lc)
(61, ])
(56, .)
(64, sum)
(35, +)
(65, 1)
(59, ))
(51, ;)
(64, p)
(62, :=)
(64, data)
(60, [)
(64, p)
(61, ])
(56, .)
(64, rc)
(51, ;)
(9, end)
(51, ;)
(9, end)
(51, ;)
(64, procedure)
(64, Ttree)
(56, .)
(64, Delete_Root_Lc)
(51, ;)
(2, begin)
(14, if)
(64, rootT)
(43, =)
(28, nilT)
(28, then)
(64, exit)
(51, ;)
(14, if)
(64, data)
(60, [)
(64, rootT)
(61, ])
(56, .)
(64, Rc)
(43, =)
(28, nilT)
(28, then)
(2, begin)
(64, rootT)
(62, :=)
(28, nilT)
(51, ;)
(64, exit)
(51, ;)
(9, end)
(51, ;)
(64, rootT)
(62, :=)
(64, data)
(60, [)
(64, rootT)
(61, ])
(56, .)
(64, Rc)
(51, ;)
(64, data)
(60, [)
(64, rootT)
(61, ])
(56, .)
(64, father)
(62, :=)
(28, nilT)
(51, ;)
(9, end)
(51, ;)
(64, procedure)
(64, main)
(51, ;)
(32, var)
(64, i)
(49, ,)
(64, K)
(49, ,)
(64, p)
(50, :)
(64, longint)
(51, ;)
(64, ch)
(50, :)
(64, char)
(51, ;)
(2, begin)
(64, assign)
(58, ()
(64, INPUT)
(49, ,)
(64, InFile)
(59, ))
(51, ;)
(64, ReSet)
(58, ()
(64, INPUT)
(59, ))
(51, ;)
(64, assign)
(58, ()
(64, OUTPUT)
(49, ,)
(64, OutFile)
(59, ))
(51, ;)
(64, ReWrite)
(58, ()
(64, OUTPUT)
(59, ))
(51, ;)
(64, readln)
(58, ()
(64, N)
(49, ,)
(64, Bound)
(59, ))
(51, ;)
(24, init_Bound)
(62, :=)
(64, Bound)
(51, ;)
(64, tree)
(56, .)
(15, init)
(51, ;)
(64, totLeft)
(62, :=)
(65, 0;)
(11, for)
(64, i)
(62, :=)
(65, 1)
(29, to)
(64, N)
(6, do)
(2, begin)
(64, readln)
(58, ()
(64, ch)
(49, ,)
(64, K)
(59, ))
(51, ;)
(3, case)
(64, ch)
(20, of)
(67, 'I')
(50, :)
(2, begin)
(14, if)
(64, K)
(47, <)
(24, init_Bound)
(28, then)
(64, inc)
(58, ()
(64, totLeft)
(59, ))
(8, else)
(64, tree)
(56, .)
(64, Insert)
(58, ()
(64, K)
(36, -)
(24, init_Bound)
(35, +)
(64, Bound)
(59, ))
(51, ;)
(9, end)
(51, ;)
(67, 'A')
(50, :)
(64, dec)
(58, ()
(64, Bound)
(49, ,)
(64, K)
(59, ))
(51, ;)
(67, 'S')
(50, :)
(2, begin)
(64, inc)
(58, ()
(64, Bound)
(49, ,)
(64, K)
(59, ))
(51, ;)
(64, p)
(62, :=)
(64, tree)
(56, .)
(64, Find)
(58, ()
(64, Bound)
(59, ))
(51, ;)
(14, if)
(64, p)
(44, <>)
(36, -)
(65, 1)
(28, then)
(2, begin)
(64, tree)
(56, .)
(64, Splay)
(58, ()
(64, p)
(59, ))
(51, ;)
(64, inc)
(58, ()
(64, totLeft)
(49, ,)
(64, tree)
(56, .)
(64, data)
(60, [)
(64, tree)
(56, .)
(64, data)
(60, [)
(64, p)
(61, ])
(56, .)
(64, lc)
(61, ])
(56, .)
(64, sum)
(35, +)
(65, 1)
(59, ))
(51, ;)
(64, tree)
(56, .)
(64, Delete_Root_Lc)
(51, ;)
(9, end)
(51, ;)
(9, end)
(51, ;)
(67, 'F')
(50, :)
(2, begin)
(64, p)
(62, :=)
(64, tree)
(56, .)
(64, Find_Index)
(58, ()
(64, K)
(59, ))
(51, ;)
(14, if)
(64, p)
(43, =)
(36, -)
(65, 1)
(28, then)
(64, writeln)
(58, ()
(36, -)
(65, 1)
(59, ))
(51, ;)
(8, else)
(64, writeln)
(58, ()
(64, tree)
(56, .)
(64, data)
(60, [)
(64, p)
(61, ])
(56, .)
(64, key)
(36, -)
(64, Bound)
(35, +)
(24, init_Bound)
(59, ))
(51, ;)
(9, end)
(51, ;)
(9, end)
(51, ;)
(9, end)
(51, ;)
(64, writeln)
(58, ()
(64, totLeft)
(59, ))
(51, ;)
(64, Close)
(58, ()
(64, OUTPUT)
(59, ))
(51, ;)
(64, Close)
(58, ()
(64, INPUT)
(59, ))
(51, ;)
(9, end)
(51, ;)
(2, Begin)
(64, main)
(51, ;)
(9, End)
(56, .)
